// This file has been automatically generated by jagp.

#pragma once

#include <iostream>
#include <stdint.h>
{% if Component_globals.hasToStdString %}
#include <string>
{% endif %}

/// @brief This class is the most basic building block for jagp.
/// Every packet can be described as an ordered list (vector) of Components.
/// jagp will generate a derived class for each user-specified Component.
/// Each user-specified Component defines the individual bit-sized/byte-sized
/// fields that are to be read from/written to a raw buffer.
class Component
{
public:
    Component(
        size_t numBytes
    ) : m_numBytes(numBytes)
    {
    }

    size_t size() const { return m_numBytes; }

    /// @brief Method that writes the Component's fields to the buffer; to be implemented in sub-classes.
    /// @param buf Pointer to the (remaining) buffer. Buffer is assumed to be pre-zeroed.
    /// The buffer pointer is updated to point to the next byte after the Component.
    /// @param buflen Size of the (remaining) buffer in bytes.
    void write(uint8_t *buf, size_t buflen)
    {
        throw std::runtime_error("Component::write() called: this should never be called directly, and should be re-implemented in child classes.")
    };

    /// @brief Method that reads the Component's fields from the buffer
    /// @param buf Pointer to the (remaining) buffer.
    /// The buffer pointer is updated to point to the next byte after the Component.
    /// @param buflen Size of the (remaining) buffer in bytes.
    void read(const uint8_t *buf, size_t buflen)
    {
        throw std::runtime_error("Component::read() called: this should never be called directly, and should be re-implemented in child classes.")
    }

    {% if Component_globals.hasToCString %}
    void toCString(char* s, size_t len);
    {% endif %}
    {% if Component_globals.hasToStdString %}
    std::string toStdString() = 0;
    {% endif %}

    // TODO: implement read/write for Components that occupy sub-bytes

protected:
    size_t m_numBytes;
};