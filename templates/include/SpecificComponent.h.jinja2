{% from 'macros.jinja2' import contiguousBitmask, lrshift %}
// This file has been automatically generated by jagp.

#pragma once

#include <string>
#include <stdint.h>

namespace Component{

    class {{ component.name }}
    {
    public:
        /// @brief Empty constructor. Used when fields are set later on.
        {{ component.name }}()
        {
        }

        /// @brief Empty constructor with fixed size. Used if component has a fixed size.
        {{ component.name }}(size_t numBytes)
            : m_numBytes(numBytes)
        {
        }

        {% for field in component.fields %}
        /// @brief Gets the {{loop.index}}/{{loop.length}} field: {{field.name}}
        {{ field.type }} {% if Component_globals.use_get_prefix %}get_{% endif %}{{ field.name }}(){ return m_{{ field.name }}; }
        /// @brief Sets the {{loop.index}}/{{loop.length}} field: {{field.name}}
        void set_{{ field.name }}({{ field.type }} value){ m_{{ field.name }} = value; }
        {# leave a space between fields for readability#}

        {% endfor %}

        void write(uint8_t *buf, size_t buflen)
        {
            // Check if the buffer is large enough to write the component
            if (buflen < m_numBytes)
                throw std::out_of_range("{{ component.name }}: Buffer is too small");

            // Write each field
            {% for field in component.fields %}
            {# 
                Handle the matrix of combinations:
                1) Byte-aligned offsets
                2) Bit-aligned offsets
                A) Byte-multiple sized fields
                B) Arbitrary sized fields
            #}
            {% if field.bit_offset == 0 and field.size % 8 == 0%}
            {# 
                BYTE-ALIGNED & BYTE-MULTIPLE
                Just a direct memcpy will work as this is the simplest case.
            #}
            std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));
            {% else %}
            {#
                For all other cases, we use the sections iterable provided in the field to help us.
                The sections mask provides the number of bits for every byte starting from the byte_offset.
            #}
            {% for bitEnd in field.sections %}
            {% if loop.index0 == 0 %}
            {# The first loop must take the bit_offset into consideration #}
            buf[{{field.byte_offset}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, 0, bitEnd)}} ){{lrshift(field.size-8+field.bit_offset)}}; // Section 1
            {% else %}
            {% if bitEnd - field.sections[loop.index0-1] == 8 %}
            buf[{{field.byte_offset + loop.index0}}] = ( m_{{field.name}} & {{contiguousBitmask(field.size, bitEnd-8, bitEnd)}} ){{lrshift(field.size-bitEnd)}}; // Section {{loop.index}}
            {% else %}
            buf[{{field.byte_offset + loop.index0}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, field.sections[loop.index0-1], bitEnd)}} ){{lrshift(-8+bitEnd-field.sections[loop.index0-1])}}; // Section {{loop.index}}
            {% endif %}
            {% endif %}
                {% endfor %}
            {% endif %}
            // --------------------
            {% endfor %}

            // Change the pointer to remaining part of the buffer
            buf += m_numBytes;
        }

        void read(const uint8_t *buf, size_t buflen)
        {
            // Check if the buffer is large enough to read the component
            if (buflen < m_numBytes)
                throw std::out_of_range("{{ component.name }}: Buffer is too small");

            // Read each field
            {% for field in component.fields %}
            {# 
                Handle the matrix of combinations:
                1) Byte-aligned offsets
                2) Bit-aligned offsets
                A) Byte-multiple sized fields
                B) Arbitrary sized fields
            #}
            {% if field.bit_offset == 0 and field.size % 8 == 0%}
            {# 
                BYTE-ALIGNED & BYTE-MULTIPLE
                Just a direct memcpy will work as this is the simplest case.
            #}
            std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
            {% else %}
            {#
                For all other cases, we use the sections iterable provided in the field to help us.
                The sections mask provides the number of bits for every byte starting from the byte_offset.

                TODO: It may be significantly easier to make a pointer size that encompasses the variable,
                and then mask from it once to read it instead.
                We can do this as an if/else checking the buffer size and making sure we can read enough bytes?
                For now just read byte by byte if necessary?
            #}
            {% for bitEnd in field.sections %}
            {% if loop.index0 == 0 %}
            {# The first loop must take the bit_offset into consideration #}
            m_{{field.name}} |= ( buf[{{field.byte_offset}}] & {{contiguousBitmask(8, field.bit_offset, field.bit_offset+bitEnd)}} ){{lrshift(-field.size+8-field.bit_offset)}}; // Section 1
            {% else %}
            {% if bitEnd - field.sections[loop.index0-1] == 8 %}
            m_{{field.name}} |= buf[{{field.byte_offset + loop.index0}}]{{lrshift(-field.size+8+field.sections[loop.index0-1])}}; // Section {{loop.index}}
            {% else %}
            m_{{field.name}} |= ( buf[{{field.byte_offset + loop.index0}}] & {{contiguousBitmask(8, 0, bitEnd-field.sections[loop.index0-1])}} ){{lrshift(8-bitEnd+field.sections[loop.index0-1])}}; // Section {{loop.index}}
            {% endif %}
            {% endif %}
            {% endfor %}
            {% endif %}
            // --------------------
            {% endfor %}

            // Change the pointer to remaining part of the buffer
            buf += m_numBytes;
        }

        {% if Component_globals.hasToCString %}
        void toCString(char* s, size_t len)
        {
            std::snprintf(s, len,
                "{{component.name}}\n"
            );
            // TODO: complete with fields?
        }
        {% endif %}
        {% if Component_globals.hasToStdString %}
        std::string toStdString()
        {
            std::string s;
            s = "{{component.name}}\n";
            // TODO: complete with fields?

            return s;
        }
        {% endif %}

    private:
        size_t m_numBytes = 0;

        {% for field in component.fields %}
        {{ field.type }} m_{{ field.name }} = 0;
        {% endfor %}
    };

} // namespace Component