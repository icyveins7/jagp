// This file has been automatically generated by jagp.

#pragma once

#include "Component.h"

{# Define macro here for now; to move out and import eventually #}
{% macro contiguousBitmask(len, start, end) -%}
0b{% for i in range(len) %}{% if i >= start and i < end %}1{% else %}0{% endif %}{% endfor %}
{%- endmacro %}

{# Performs left or right shift for negative/positive values; 0 values are ignored #}
{% macro lrshift(shift) -%}
{% if shift > 0 %} >> {{ shift }}{% elif shift < 0 %} << {{ -shift }}{% endif %}
{%- endmacro %}

class {{ component.name }} : public Component
{
public:
    {{ component.name }}()
        : Component({{ component.numBytes }})
    {
    }

    {% for field in component.fields %}
    /// @brief Gets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    {{ field.type }} {% if Component_globals.use_get_prefix %}get_{% endif %}{{ field.name }}(){ return m_{{ field.name }}; }
    /// @brief Sets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    void set_{{ field.name }}({{ field.type }} value){ m_{{ field.name }} = value; }
    {# leave a space between fields for readability#}

    {% endfor %}

    virtual void write(uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to write the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ component.name }}: Buffer is too small");

        // Write each field
        {% for field in component.fields %}
        {# 
            Handle the matrix of combinations:
            1) Byte-aligned offsets
            2) Bit-aligned offsets
            A) Byte-multiple sized fields
            B) Arbitrary sized fields
        #}
        {% if field.bit_offset == 0 and field.size % 8 == 0%}
            {# 
                BYTE-ALIGNED & BYTE-MULTIPLE
                Just a direct memcpy will work as this is the simplest case.
            #}
            std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));
        {% else %}
            {#
                For all other cases, we use the sections iterable provided in the field to help us.
                The sections mask provides the number of bits for every byte starting from the byte_offset.
            #}
            {% for bitEnd in field.sections %}
            {% if loop.index0 == 0 %}
            {# The first loop must take the bit_offset into consideration #}
            buf[{{field.byte_offset}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, 0, bitEnd)}} ){{lrshift(field.size-8+field.bit_offset)}}; // Section 1 (TODO: fix formula for bitshifts)
            {% else %}
                {% if bitEnd - field.sections[loop.index0-1] == 8 %}
                buf[{{field.byte_offset + loop.index0}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, bitEnd-8, bitEnd)}} ){{lrshift(field.size-bitEnd)}}; // Section {{loop.index}}
                {% else %}
                buf[{{field.byte_offset + loop.index0}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, field.sections[loop.index0-1], bitEnd)}} ){{lrshift(-8+bitEnd-field.sections[loop.index0-1])}}; // Section {{loop.index}}
                {% endif %}
            {% endif %}
            {% endfor %}
        {% endif %}
        // --------------------
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    virtual void read(const uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to read the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ component.name }}: Buffer is too small");

        // Read each field
        {% for field in component.fields %}
        {# Handle byte offsets #}
        {% if field.size % 8 == 0 %}
        std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
        {# Handle bit offsets #}
        {% else %}
        {% if 8 - field.size - field.bit_offset == 0 %}
        m_{{field.name}} = (buf[{{ field.byte_offset }}] & 0b{% for i in range(field.size) %}1{% endfor %});
        {% else %}
        m_{{field.name}} = ((buf[{{field.byte_offset}}] >> {{8-field.bit_offset-field.size}}) & 0b{% for i in range(field.size) %}1{% endfor %});
        {% endif %}
        {% endif %}
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    {% if Component_globals.hasPrint %}
    virtual void print() override
    {
        // TODO
    }
    {% endif %}
    {% if Component_globals.hasToCString %}
    virtual void toCString(char* s) override
    {
        // TODO
    }
    {% endif %}
    {% if Component_globals.hasToStdString %}
    virtual std::string toStdString() override
    {
        // TODO
    }
    {% endif %}

private:
    {% for field in component.fields %}
    {{ field.type }} m_{{ field.name }};
    {% endfor %}
};