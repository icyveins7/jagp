// This file has been automatically generated by jagp.

#pragma once

#include "Component.h"

{# Define macro here for now; to move out and import eventually #}
{% macro contiguousBitmask(len, start, end) -%}
0b{% for i in range(len) %}{% if i >= start and i < end %}1{% else %}0{% endif %}{% endfor %}
{%- endmacro %}

{# Performs left or right shift for negative/positive values; 0 values are ignored #}
{% macro lrshift(shift) -%}
{% if shift > 0 %} >> {{ shift }}{% elif shift < 0 %} << {{ -shift }}{% endif %}
{%- endmacro %}

class {{ component.name }} : public Component
{
public:
    {{ component.name }}()
        : Component({{ component.numBytes }})
    {
    }

    {% for field in component.fields %}
    /// @brief Gets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    {{ field.type }} {% if Component_globals.use_get_prefix %}get_{% endif %}{{ field.name }}(){ return m_{{ field.name }}; }
    /// @brief Sets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    void set_{{ field.name }}({{ field.type }} value){ m_{{ field.name }} = value; }
    {# leave a space between fields for readability#}

    {% endfor %}

    virtual void write(uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to write the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ component.name }}: Buffer is too small");

        // Write each field
        {% for field in component.fields %}
        {# 
            Handle the matrix of combinations:
            1) Byte-aligned offsets
            2) Bit-aligned offsets
            A) Byte-multiple sized fields
            B) Arbitrary sized fields
        #}
        {% if field.bit_offset == 0 and field.size % 8 == 0%}
        {# 
            BYTE-ALIGNED & BYTE-MULTIPLE
            Just a direct memcpy will work as this is the simplest case.
        #}
        std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));
        {% else %}
        {#
            For all other cases, we use the sections iterable provided in the field to help us.
            The sections mask provides the number of bits for every byte starting from the byte_offset.
        #}
        {% for bitEnd in field.sections %}
        {% if loop.index0 == 0 %}
        {# The first loop must take the bit_offset into consideration #}
        buf[{{field.byte_offset}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, 0, bitEnd)}} ){{lrshift(field.size-8+field.bit_offset)}}; // Section 1
        {% else %}
        {% if bitEnd - field.sections[loop.index0-1] == 8 %}
        buf[{{field.byte_offset + loop.index0}}] = ( m_{{field.name}} & {{contiguousBitmask(field.size, bitEnd-8, bitEnd)}} ){{lrshift(field.size-bitEnd)}}; // Section {{loop.index}}
        {% else %}
        buf[{{field.byte_offset + loop.index0}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, field.sections[loop.index0-1], bitEnd)}} ){{lrshift(-8+bitEnd-field.sections[loop.index0-1])}}; // Section {{loop.index}}
        {% endif %}
        {% endif %}
            {% endfor %}
        {% endif %}
        // --------------------
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    virtual void read(const uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to read the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ component.name }}: Buffer is too small");

        // Read each field
        {% for field in component.fields %}
        {# 
            Handle the matrix of combinations:
            1) Byte-aligned offsets
            2) Bit-aligned offsets
            A) Byte-multiple sized fields
            B) Arbitrary sized fields
        #}
        {% if field.bit_offset == 0 and field.size % 8 == 0%}
        {# 
            BYTE-ALIGNED & BYTE-MULTIPLE
            Just a direct memcpy will work as this is the simplest case.
        #}
        std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
        {% else %}
        {#
            For all other cases, we use the sections iterable provided in the field to help us.
            The sections mask provides the number of bits for every byte starting from the byte_offset.

            It may be significantly easier to make a pointer size that encompasses the variable,
            and then mask from it once to read it instead.
        #}
        {{field.type}}* {{field.name}} = reinterpret_cast<{{field.type}}>(&buf[{{field.byte_offset}}]); // Read a block big enough to contain the variable? May get out-of-bounds errors i think..

        {% for bitEnd in field.sections %}
        {% if loop.index0 == 0 %}
        {# The first loop must take the bit_offset into consideration #}
        m_{{field.name}} |= ( buf[{{field.byte_offset}}] & {{contiguousBitmask(8, field.bit_offset, field.bit_offset+bitEnd)}} ){{lrshift(-field.size+8-field.bit_offset)}}; // Section 1
        {% else %}
        {% if bitEnd - field.sections[loop.index0-1] == 8 %}
        m_{{field.name}} |= buf[{{field.byte_offset + loop.index0}}]{{lrshift(-field.size+8-field.sections[loop.index0-1])}}; // Section {{loop.index}} TODO
        {% else %}
        buf[{{field.byte_offset + loop.index0}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, field.sections[loop.index0-1], bitEnd)}} ){{lrshift(-8+bitEnd-field.sections[loop.index0-1])}}; // Section {{loop.index}} TODO
        {% endif %}
        {% endif %}
        {% endfor %}
        {% endif %}
        // --------------------
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    {% if Component_globals.hasPrint %}
    virtual void print() override
    {
        // TODO
    }
    {% endif %}
    {% if Component_globals.hasToCString %}
    virtual void toCString(char* s) override
    {
        // TODO
    }
    {% endif %}
    {% if Component_globals.hasToStdString %}
    virtual std::string toStdString() override
    {
        // TODO
    }
    {% endif %}

private:
    {% for field in component.fields %}
    {{ field.type }} m_{{ field.name }} = 0;
    {% endfor %}
};