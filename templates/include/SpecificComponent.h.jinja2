{% from 'macros.jinja2' import contiguousBitmask, lrshift %}
// This file has been automatically generated by jagp.

#pragma once

#include <string>
#include <stdint.h>
#include <stdexcept>

{% if Component_globals.enclose_components_in_namespace %}
namespace Component{
{% endif %}

class {{ name }}
{
public:
    /// @brief Empty constructor. This initializes the internal size to the size of all fixed-size fields.
    {{ name }}()
        : m_numBytes({{component.numBytes}}) // This is the size of the fixed field bytes
    {
    }

    /// @brief Returns the size (in bytes) of this component. Should return a dynamic value if there are variable-sized fields
    inline size_t size() const {
        return m_numBytes{% for field in component.fields %}{%if field.repeats is defined %} + m_{{field.name}}.size()*sizeof({{field.type}}){% endif %}{% endfor %};
    }

    {% for field in component.fields %}
    /// @brief Gets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    {{ field.type }} {% if Component_globals.use_get_prefix %}get_{% endif %}{{ field.name }}(){ return m_{{ field.name }}; }
    /// @brief Sets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    void set_{{ field.name }}({{ field.type }} value){ m_{{ field.name }} = value; }
    {# leave a space between fields for readability#}

    {% endfor %}

    /// @brief Method that writes the {{name}}'s fields to the buffer.
    /// @param buf Pointer to the (remaining) buffer. Buffer is assumed to be pre-zeroed.
    /// The buffer pointer is updated to point to the next byte after the Component.
    /// @param buflen Size of the (remaining) buffer in bytes.
    void write(uint8_t *buf, size_t buflen)
    {
        // Check if the buffer is large enough to write the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ name }}: Buffer is too small");

        // Write each field
        {% for field in component.fields %}
        {# 
            Handle the matrix of combinations:
            1) Byte-aligned offsets
            2) Bit-aligned offsets
            A) Byte-multiple sized fields
            B) Arbitrary sized fields
        #}
        {% if field.bit_offset == 0 and field.size % 8 == 0%}
        {# 
            BYTE-ALIGNED & BYTE-MULTIPLE
            Just a direct memcpy will work as this is the simplest case.
        #}
        std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));
        {% else %}
        {#
            For all other cases, we use the sections iterable provided in the field to help us.
            The sections mask provides the number of bits for every byte starting from the byte_offset.
        #}
        {% for bitEnd in field.sections %}
        {% if loop.index0 == 0 %}
        {# The first loop must take the bit_offset into consideration #}
        buf[{{field.byte_offset}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, 0, bitEnd)}} ){{lrshift(field.size-8+field.bit_offset)}}; // Section 1
        {% else %}
        {% if bitEnd - field.sections[loop.index0-1] == 8 %}
        buf[{{field.byte_offset + loop.index0}}] = ( m_{{field.name}} & {{contiguousBitmask(field.size, bitEnd-8, bitEnd)}} ){{lrshift(field.size-bitEnd)}}; // Section {{loop.index}}
        {% else %}
        buf[{{field.byte_offset + loop.index0}}] |= ( m_{{field.name}} & {{contiguousBitmask(field.size, field.sections[loop.index0-1], bitEnd)}} ){{lrshift(-8+bitEnd-field.sections[loop.index0-1])}}; // Section {{loop.index}}
        {% endif %}
        {% endif %}
            {% endfor %}
        {% endif %}
        // --------------------
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += size();
    }

    /// @brief Method that reads the {{name}}'s fields from the buffer.
    /// @param buf Pointer to the (remaining) buffer.
    /// The buffer pointer is updated to point to the next byte after the Component.
    /// @param buflen Size of the (remaining) buffer in bytes.
    void read(const uint8_t *buf, size_t buflen)
    {
        // Check if the buffer is large enough to read the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ name }}: Buffer is too small");

        // Read each field
        {% for field in component.fields %}
        {# 
            Handle the matrix of combinations:
            1) Byte-aligned offsets
            2) Bit-aligned offsets
            A) Byte-multiple sized fields
            B) Arbitrary sized fields
        #}
        {% if field.bit_offset == 0 and field.size % 8 == 0%}
        {# 
            BYTE-ALIGNED & BYTE-MULTIPLE
            Just a direct memcpy will work as this is the simplest case.
        #}
        std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
        {% else %}
        {#
            For all other cases, we use the sections iterable provided in the field to help us.
            The sections mask provides the number of bits for every byte starting from the byte_offset.

            TODO: It may be significantly easier to make a pointer size that encompasses the variable,
            and then mask from it once to read it instead.
            We can do this as an if/else checking the buffer size and making sure we can read enough bytes?
            For now just read byte by byte if necessary?
        #}
        {% for bitEnd in field.sections %}
        {% if loop.index0 == 0 %}
        {# The first loop must take the bit_offset into consideration #}
        m_{{field.name}} |= ( buf[{{field.byte_offset}}] & {{contiguousBitmask(8, field.bit_offset, field.bit_offset+bitEnd)}} ){{lrshift(-field.size+8-field.bit_offset)}}; // Section 1
        {% else %}
        {% if bitEnd - field.sections[loop.index0-1] == 8 %}
        m_{{field.name}} |= buf[{{field.byte_offset + loop.index0}}]{{lrshift(-field.size+8+field.sections[loop.index0-1])}}; // Section {{loop.index}}
        {% else %}
        m_{{field.name}} |= ( buf[{{field.byte_offset + loop.index0}}] & {{contiguousBitmask(8, 0, bitEnd-field.sections[loop.index0-1])}} ){{lrshift(8-bitEnd+field.sections[loop.index0-1])}}; // Section {{loop.index}}
        {% endif %}
        {% endif %}
        {% endfor %}
        {% endif %}
        // --------------------
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += size();
    }

    {% if Component_globals.hasToCString %}
    void toCString(char* s, size_t len)
    {
        std::snprintf(s, len,
            "{{name}}\n"
        );
        // TODO: complete with fields?
    }
    {% endif %}
    {% if Component_globals.hasToStdString %}
    std::string toStdString()
    {
        std::string s;
        s = "{{name}}\n";
        // TODO: complete with fields?

        return s;
    }
    {% endif %}

private:
    /// @brief Sum of the sizes of all fixed-size fields.
    size_t m_numBytes = 0;

    // === Member fields ===

    {% for field in component.fields %}
    {% if field.repeats is defined %}
    std::vector<{{field.type}}> m_{{field.name}};
    {% else %}
    {{ field.type }} m_{{ field.name }} = 0;
    {% endif %}
    {% endfor %}
};

{% if Component_globals.enclose_components_in_namespace %}
} // namespace Component
{% endif %}