// This file has been automatically generated by jagp.

#pragma once

#include "Component.h"

{# Define macro here for now; to move out and import eventually #}
{% macro contiguousBitmask(len, start, end) -%}
0b{% for i in range(len) %}{% if i >= start and i < end %}1{% else %}0{% endif %}{% endfor %}
{%- endmacro %}

class {{ component.name }} : public Component
{
public:
    {{ component.name }}()
        : Component({{ component.numBytes }})
    {
    }

    {% for field in component.fields %}
    /// @brief Gets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    {{ field.type }} {% if Component_globals.use_get_prefix %}get_{% endif %}{{ field.name }}(){ return m_{{ field.name }}; }
    /// @brief Sets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    void set_{{ field.name }}({{ field.type }} value){ m_{{ field.name }} = value; }
    {# leave a space between fields for readability#}

    {% endfor %}

    virtual void write(uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to write the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ component.name }}: Buffer is too small");

        // Write each field
        {% for field in component.fields %}
        {# 
            Handle the matrix of combinations:
            1) Byte-aligned offsets
            2) Bit-aligned offsets
            A) Byte-multiple sized fields
            B) Arbitrary sized fields
        #}
        {% if field.bit_offset == 0 %}{# BYTE-ALIGNED #}
            {% if field.size % 8 == 0 %}
            {# 
                BYTE-ALIGNED & BYTE-MULTIPLE
                Just a direct memcpy will work as this is the simplest case.
            #}
            std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));

            {% else %}
            {# 
                BYTE-ALIGNED, NON-BYTE-MULTIPLE
                Since it begins byte-aligned, we can copy the nearest byte-multiple size of bytes first.
                THen we copy the remaining bits.
            #}
                {% if field.size // 8 > 0 %}{# Write the largest byte-multiple #}
                std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, {{ field.size // 8 }});
                {% endif %}
                {# Then copy the remaining bits; note that this also runs when the field is less than a byte #}
                buf[{{ field.byte_offset + (field.size // 8) }}] |= (m_{{ field.name }} & {{ contiguousBitmask(field.size, field.size//8*8, field.size) }}) << {{ 8-field.bit_offset-(field.size%8) }};
            {% endif %}
        {% else %}{# BIT-ALIGNED #}
            {% if field.size <= (8-field.bit_offset) %}
            {# 
                BIT-ALIGNED & CAN FIT IN CURRENT BYTE
                Then we can just copy the bits in-place
            #}
            buf[{{ field.byte_offset }}] |= (m_{{ field.name }} & {{ contiguousBitmask(field.size, 0, field.size)}}) << {{ 8-field.size-field.bit_offset }};
            {% else %}
            {# 
                BIT-ALIGNED & LARGER THAN REMAINING BITS IN CURRENT BYTE
                Copy the starting bits to fill the byte, 
                then copy the maximum number of full bytes, 
                and then copy the final ending bits
            #}
            {# Copy initial bits; note that this is a right-shift #}
            buf[{{ field.byte_offset }}] |= ( (m_{{ field.name }} & {{ contiguousBitmask(field.size, 0, 8-field.bit_offset) }}) >> {{ field.size-8+field.bit_offset }} );
            {# Copy remaining bytes (if there's at least one byte more) #}
            {# Loop over the bytes and write the masked bits appropriately; We cannot use memcpy because we cannot arbitrarily address into bit-offsets #}
            {% for j in range((field.size-8+field.bit_offset) // 8)%}
            buf[{{ field.byte_offset + j + 1 }}] = ( (m_{{ field.name }} & {{ contiguousBitmask(field.size, 8-field.bit_offset+8*j, 8-field.bit_offset+8*(j+1)) }}) >> {{field.size-8+field.bit_offset-8*(j+1)}} );
            {% endfor %}
            {# Copy ending bits #}
            // TODO
            {% endif %}
        {% endif %}

        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    virtual void read(const uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to read the component
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ component.name }}: Buffer is too small");

        // Read each field
        {% for field in component.fields %}
        {# Handle byte offsets #}
        {% if field.size % 8 == 0 %}
        std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
        {# Handle bit offsets #}
        {% else %}
        {% if 8 - field.size - field.bit_offset == 0 %}
        m_{{field.name}} = (buf[{{ field.byte_offset }}] & 0b{% for i in range(field.size) %}1{% endfor %});
        {% else %}
        m_{{field.name}} = ((buf[{{field.byte_offset}}] >> {{8-field.bit_offset-field.size}}) & 0b{% for i in range(field.size) %}1{% endfor %});
        {% endif %}
        {% endif %}
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    {% if Component_globals.hasPrint %}
    virtual void print() override
    {
        // TODO
    }
    {% endif %}
    {% if Component_globals.hasToCString %}
    virtual void toCString(char* s) override
    {
        // TODO
    }
    {% endif %}
    {% if Component_globals.hasToStdString %}
    virtual std::string toStdString() override
    {
        // TODO
    }
    {% endif %}

private:
    {% for field in component.fields %}
    {{ field.type }} m_{{ field.name }};
    {% endfor %}
};