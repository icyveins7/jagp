// This file has been automatically generated by jagp.

#pragma once

#include "Header.h"

class {{ header.name }} : public Header
{
public:
    {{ header.name }}()
        : Header({{ header.numBytes }})
    {
    }

    {% for field in header.fields %}
    /// @brief Gets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    {{ field.type }} get_{{ field.name }}(){ return m_{{ field.name }}; }
    /// @brief Sets the {{loop.index}}/{{loop.length}} field: {{field.name}}
    void set_{{ field.name }}({{ field.type }} value){ m_{{ field.name }} = value; }

    {% endfor %}

    virtual void write(uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to write the header
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ header.name }}: Buffer is too small");

        // Write each field
        {% for field in header.fields %}
        {# Handle byte offsets #}
        {% if field.size % 8 == 0 %}
        std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));
        {# Handle bit offsets #}
        {% else %}
        {% if 8 - field.size - field.bit_offset == 0 %}
        buf[{{ field.byte_offset }}] |= ({{field.name}} & 0b{% for i in range(field.size) %}1{% endfor %});
        {% else %}
        buf[{{ field.byte_offset }}] |= (({{field.name}} & 0b{% for i in range(field.size) %}1{% endfor %}) << {{8-field.bit_offset-field.size}});
        {% endif %}
        {% endif %}
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    virtual void read(const uint8_t *buf, size_t buflen) override
    {
        // Check if the buffer is large enough to read the header
        if (buflen < m_numBytes)
            throw std::out_of_range("{{ header.name }}: Buffer is too small");

        // Read each field
        {% for field in header.fields %}
        {# Handle byte offsets #}
        {% if field.size % 8 == 0 %}
        std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
        {# Handle bit offsets #}
        {% else %}
        {% if 8 - field.size - field.bit_offset == 0 %}
        m_{{field.name}} = (buf[{{ field.byte_offset }}] & 0b{% for i in range(field.size) %}1{% endfor %});
        {% else %}
        m_{{field.name}} = ((buf[{{field.byte_offset}}] >> {{8-field.bit_offset-field.size}}) & 0b{% for i in range(field.size) %}1{% endfor %});
        {% endif %}
        {% endif %}
        {% endfor %}

        // Change the pointer to remaining part of the buffer
        buf += m_numBytes;
    }

    {% if header_globals.hasPrint %}
    virtual void print() override
    {
        // TODO
    }
    {% endif %}
    {% if header_globals.hasToCString %}
    virtual void toCString(char* s) override
    {
        // TODO
    }
    {% endif %}
    {% if header_globals.hasToStdString %}
    virtual std::string toStdString() override
    {
        // TODO
    }
    {% endif %}

private:
    {% for field in header.fields %}
    {{ field.type }} m_{{ field.name }};
    {% endfor %}
};