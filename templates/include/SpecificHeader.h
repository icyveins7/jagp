// This file has been automatically generated by jagp.

#pragma once

#include "Header.h"

class {{ header.name }} : public Header
{
public:
    {% if header.usesExtraBits %}
    {{ header.name }}()
        : Header({{ header.numBytes }}, {{ header.numExtraBits }})
    {
    }
    {% else %}
    {{ header.name }}()
        : Header({{ header.numBytes }})
    {
    }
    {% endif %}

    {% for field in header.fields %}
    {{ field.type }} get{{ field.name }}(){ return {{ field.name }}; }
    void set{{ field.name }}({{ field.type }} value){ {{ field.name }} = value; }
    {% endfor %}

    virtual uint8_t* write(uint8_t *buf, size_t &bufbitslen) override
    {
        // Check if the buffer is large enough to write the header
        if (buflen < (m_numBytes * 8{% if header.usesExtraBits %} + m_numExtraBits{% endif %}))
            throw std::out_of_range("{{ header.name }}: Buffer is too small");

        // Write each field
        {% for field in header.fields %}
        {# Handle byte offsets #}
        {% if field.size % 8 == 0 %}
        std::memcpy(&buf[{{ field.byte_offset }}], &m_{{ field.name }}, sizeof({{ field.type }}));
        {# Handle bit offsets #}
        {% else %}
        buf[{{ field.byte_offset }}] |= ({{field.name}} & 0b{% for i in range(field.size) %}1{% endfor %}) << {{7-field.bit_offset}};
        {% endif %}
        {% endfor %}
    }

    virtual uint8_t* read(const uint8_t *buf, size_t &buflen) override
    {
        // Check if the buffer is large enough to read the header
        if (buflen < (m_numBytes * 8{% if header.usesExtraBits %} + m_numExtraBits{% endif %}))
            throw std::out_of_range("{{ header.name }}: Buffer is too small");

        // Read each field
        {% for field in header.fields %}
        {# Handle byte offsets #}
        {% if field.size % 8 == 0 %}
        std::memcpy(&m_{{ field.name }}, &buf[{{ field.byte_offset }}], sizeof({{ field.type }}));
        {# Handle bit offsets #}
        {% else %}
        m_{{field.name}} = (buf[{{field.byte_offset}}] >> {{field.bit_offset}}) & 0b{% for i in range(field.size) %}1{% endfor %};
        {% endif %}
        {% endfor %}
    }

private:
    {% for field in header.fields %}
    {{ field.type }} m_{{ field.name }};
    {% endfor %}
};