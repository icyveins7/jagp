// This file has been automatically generated by jagp.

#pragma once

#include <iostream>
#include <stdint.h>
{% if Component_globals.hasToStdString %}
#include <string>
{% endif %}

/// @brief This class is the most basic building block for jagp.
/// Every packet can be described as an ordered list (vector) of Components.
/// jagp will generate a derived class for each user-specified Component.
/// Each user-specified Component defines the individual bit-sized/byte-sized
/// fields that are to be read from/written to a raw buffer.
class Component
{
public:
    Component(
        size_t numBytes
    ) : m_numBytes(numBytes)
    {
    }
    virtual ~Component() = default; // Require a virtual destructor for base class.

    /// @brief Pure virtual method that writes the Component's fields to the buffer
    /// @param buf Pointer to the (remaining) buffer. Buffer is assumed to be pre-zeroed.
    /// The buffer pointer is updated to point to the next byte after the Component.
    /// @param buflen Size of the (remaining) buffer in bytes.
    virtual void write(uint8_t *buf, size_t buflen) = 0;

    /// @brief Pure virtual method that reads the Component's fields from the buffer
    /// @param buf Pointer to the (remaining) buffer.
    /// The buffer pointer is updated to point to the next byte after the Component.
    /// @param buflen Size of the (remaining) buffer in bytes.
    virtual void read(const uint8_t *buf, size_t buflen) = 0;

    {% if Component_globals.hasPrint %}
    virtual void print() = 0;
    {% endif %}
    {% if Component_globals.hasToCString %}
    virtual void toCString(char* s) = 0;
    {% endif %}
    {% if Component_globals.hasToStdString %}
    virtual std::string toStdString() = 0;
    {% endif %}

    // TODO: implement read/write for Components that occupy sub-bytes

protected:
    size_t m_numBytes;
};